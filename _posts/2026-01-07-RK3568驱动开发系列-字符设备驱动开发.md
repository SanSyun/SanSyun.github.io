---
layout: post
title: "RK3568驱动开发系列-字符设备驱动开发"
date: 2026-01-07 21:55:16 +0800
category: Linux
tags: [RK3568]
excerpt: 字符设备驱动框架开发流程
featured: true 
image: /images/posts/rk3568/R.jpg
---
# 1. 字符设备驱动简介
字符设备就是一个一个字节，按照字节流进行读写操作的设备，读写数据是分先后顺序的。
# 2. Linux应用程序与驱动程序调用关系

​	在Linux 中一切皆为文件，驱动加载成功以后会在“/dev”目录下生成一个相应的文件，应用程序通过对这个名为“/dev/xxx”(xxx 是具体的驱动文件名字)的文件进行相应的操作即可实现对硬件的操作。比如现在有个叫做/dev/led的驱动文件，此文件是led灯的驱动文件。应用程序使用open函数来打开文件/dev/led，使用完成以后使用close函数关闭/dev/led这个文件。open和close就是打开和关闭led驱动的函数，如果要点亮或关闭led，那么就使用write函数来操作，也就是向此驱动写入数据，这个数据就是要关闭还是要打开led的控制参数。如果要获取led灯的状态，就用read函数从驱动中读取相应的状态。![PixPin_2026-01-07_22-06-50](../images/\rk3568\01\PixPin_2026-01-07_22-06-50.png)

​	当我们在用户空间想要实现对内核的操作，比如使用open函数打开/dev/led这个驱动，因为用户空间不能直接对内核进行操作，因此必须使用一个叫做“系统调用”的方法来实现从用户空间“陷入”到内核空间，这样才能实现对底层驱动的操作。应用程序中使用的函数例如open，在内核空间也会有一个名为open的函数供其调用。在/kernel/include/linux/fs.h中有内核驱动操作函数的定义，下面有注释的部分为常见的操作函数：

``` c
//include/linux/fs.h
struct file_operations {
	struct module *owner;//拥有该结构体的模块
	loff_t (*llseek) (struct file *, loff_t, int);//用于修改当前文件的读写位置
	ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);//用于读取设备或文件的数据
	ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);//用于向设备或文件写入数据
	ssize_t (*read_iter) (struct kiocb *, struct iov_iter *);
	ssize_t (*write_iter) (struct kiocb *, struct iov_iter *);
	int (*iopoll)(struct kiocb *kiocb, bool spin);
	int (*iterate) (struct file *, struct dir_context *);
	int (*iterate_shared) (struct file *, struct dir_context *);
	__poll_t (*poll) (struct file *, struct poll_table_struct *);//用于轮询设备或文件的状态，查询设备是否可以进行非阻塞读/写操作
	long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);//用于处理设备或文件的控制命令，与应用程序的ioctl系统调用对应
	long (*compat_ioctl) (struct file *, unsigned int, unsigned long);//与unlocked_ioctl类似，但用于处理32位应用程序在64位内核上的兼容性问题
	int (*mmap) (struct file *, struct vm_area_struct *);//用于将设备或文件映射到用户空间的虚拟内存区域
	unsigned long mmap_supported_flags;
	int (*open) (struct inode *, struct file *);//用于打开设备或文件
	int (*flush) (struct file *, fl_owner_t id);
	int (*release) (struct inode *, struct file *);//用于关闭设备或文件
	int (*fsync) (struct file *, loff_t, loff_t, int datasync);
	int (*fasync) (int, struct file *, int);//用于刷新设备或文件的数据到存储介质
	int (*lock) (struct file *, int, struct file_lock *);
	ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);
	unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);
	int (*check_flags)(int);
	int (*flock) (struct file *, int, struct file_lock *);
	ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
	ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
	int (*setlease)(struct file *, long, struct file_lock **, void **);
	long (*fallocate)(struct file *file, int mode, loff_t offset,
			  loff_t len);
	void (*show_fdinfo)(struct seq_file *m, struct file *f);
#ifndef CONFIG_MMU
	unsigned (*mmap_capabilities)(struct file *);
#endif
	ssize_t (*copy_file_range)(struct file *, loff_t, struct file *,
			loff_t, size_t, unsigned int);
	loff_t (*remap_file_range)(struct file *file_in, loff_t pos_in,
				   struct file *file_out, loff_t pos_out,
				   loff_t len, unsigned int remap_flags);
	int (*fadvise)(struct file *, loff_t, loff_t, int);

	ANDROID_KABI_RESERVE(1);
	ANDROID_KABI_RESERVE(2);
	ANDROID_KABI_RESERVE(3);
	ANDROID_KABI_RESERVE(4);
} __randomize_layout;
```

# 3. 字符设备驱动开发步骤

## 3.1  加载和卸载驱动模块

​	常见的驱动运行方式有两种：

1. 将驱动编译进Linux内核中，这样当Linux内核启动的时候就会自动运行驱动程序。
2. 是将驱动编译成模块(Linux下模块扩展名为.ko)，在Linux内核启动以后使用“modprobe”或者“insmod”命令加载驱动模块。insmod命令不能解决模块的依赖关系，比如drv.ko依赖first.ko这个模块，就必须先使用insmod命令加载first.ko这个模块，然后再加载drv.ko这个模块。但是modprobe就不会存在这个问题，modprobe会分析模块的依赖关系，然后会将所有的依赖模块都加载到内核中，因此modprobe命令相比insmod要智能一些。modprobe命令主要智能在提供了模块的依赖性分析、 错误检查、错误报告等功能，推荐使用modprobe命令来加载驱动。同理卸载驱动推荐使用rmmod，因为modprobe -r会卸载掉驱动所依赖的所有驱动，如果依赖驱动被其他驱动所依赖，可能会造成一些问题。

​	模块的加载和卸载由下面两个函数来注册：

``` c
module_init(XXX_init); //模块加载函数
module_exit(XXX_exit); //模块卸载函数
```

​	XXX_init和XXX_exit为需要注册的加载和卸载函数。当用户调用modprobe或rmmod的时候，XXX_init或XXX_exit分别就被调用。

​	当写下 `module_init(XXX_init)` 时，内核编译器并不会立即执行它，而是通过一系列宏定义，将其转化并存放在二进制文件的特定区域（Section）。

### 作为加载模块 (.ko)

​	当执行 `insmod chrdevbase.ko` 时：

1. **用户态**：`insmod` 调用 `finit_module` 系统调用。
2. **内核态**：内核调用 `load_module()` 函数，将 `.ko` 文件加载进内存。
3. **解析符号**：内核查找模块中的 `init` 指针（即你定义的 `chrdevbase_init`）。
4. **执行**：最后通过 `do_init_module()` 调用该函数，完成注册。

### 作为内核内置 (Built-in)

​	当内核启动时，流程如下：

1. 内核启动到后期会进入 `do_initcalls()` 函数。
2. 该函数会**遍历**在编译阶段生成的 `.initcall.init` 段。
3. 按照优先级顺序，挨个执行这些函数指针。

## 3.2 字符设备注册与注销

​	上面讲了模块的加载卸载的注册，接下来需要做一些操作以指明当前加载与卸载的驱动是字符设备驱动，因此当驱动模块加载成功以后需要注册字符设备，同样，卸载驱动模块的时候也需要注销掉字符设备。

​	字符设备的注册和注销函数原型如下：

``` c
//注册字符设备
static inline int register_chrdev(unsigned int major,  //主设备号，Linux下每个设备都有一个设备号
							   const char *name,    //设备名字，指向一串字符串 
							   const struct file_operations *fops    //结构体file_operations 类型指针，指向设备的操作函数集合变量
							   );
                               
//注销字符设备
static inline void unregister_chrdev(unsigned int major, 	//注销设备的主设备号
								  const char *name		 //设备名字
								  );
```

​	为了方便管理，Linux中每个设备都有一个设备号，设备号由主设备号和次设备号两部分 组成，主设备号表示某一个具体的驱动，次设备号表示使用这个驱动的各个设备。Linux提供了 一个名为dev_t的数据类型表示设备号，dev_t定义在文件include/linux/types.h里面，定义如下

``` C
 typedef u32 __kernel_dev_t;
 typedef __kernel_dev_t dev_t;
```

​	dev_t为32位的，高12位为主设备号，低20位为次设备号。因此Linux系统中主设备号范围为0~4095，所以在选择主设备号的时候一定不要超过这个范围。在文件include/linux/kdev_t.h中提供了几个关于设备号的操作函数(本质是宏)，如下所示：

``` c
#define MINORBITS  		20 //宏MINORBITS表示次设备号位数  
#define	MINORMASK		((1U << MINORBITS) - 1) //表示次设备号掩码	
#define MAJOR(dev)		((unsigned int) ((dev) >> MINORBITS)) //宏MAJOR用于从dev_t中获取主设备号
#define MINOR(dev)		((unsigned int) ((dev) & MINORMASK)) //宏MINOR用于从dev_t中获取次设备号
#define MKDEV(ma,mi)	(((ma) << MINORBITS) | (mi)) //宏MKDEV用于将给定的主设备号和次设备号的值组合成dev_t类型的设备号
```

​	查看当前使用掉的设备号：

``` bash
cat/proc/devices
```

​	对于设备号，我们在加载和卸载驱动的时候也要对应的申请和释放对应的设备号，主要原型函数如下：

``` c
int alloc_chrdev_region(dev_t *dev, //保存申请到的设备号
                        unsigned baseminor, //次设备号起始地址，其从0开始，主设备号一样
                        unsigned count, //要申请的设备号数量
                        const char *name //设备名字
                       );
void unregister_chrdev_region(dev_t from, //要释放的设备号
                              unsigned count //要释放的设备号数量
                             );
```



## 3.3 实现设备的具体操作函数

​	在这里我们需要将fs.h结构题中提出的函数与应用层想要对驱动实施的操作进行关联。在初始化file_operations结构体之前我们要分析一下需求，也就是要对这个设备进行哪些操作，只有确定了需求以后才知道我们应该实现哪些操作函数。

​	实现的操作中最基本的就是打开、关闭、写入和读取这四个，这四个分别对应file_operations中的open、release、write和read函数。下面是实现的用例，从中我们可以发现，我们实现的这些操作函数的参数与file_operations结构体中对应函数的参数是一一对应的。

``` c
//打开设备
static int chrdevbase_open(struct inode *inode, struct file *filp)
{
    /* 用户实现具体功能 */
    return 0;
}

//关闭设备
static int chrdevbase_release(struct inode *inode, struct file *filp)
{
    /* 用户实现具体功能 */
    return 0;
}

//从内核设备读取数据
static ssize_t chrdevbase_read(struct file *filp, char __user *buf, size_t len, loff_t *offset)
{
    /* 用户实现具体功能 */
    return 0;
}

//向内核设备写入数据
static ssize_t chrdevbase_write(struct file *filp, const char __user *buf, size_t len, loff_t *offset)
{
    /* 用户实现具体功能 */
    return 0;
}
```

​	在 Linux 内核驱动开发中，`inode`是一个非常核心的结构体。可以把它理解为**文件的“身份证”**，在 `chrdevbase_open` 这一层级，`inode` 主要有两个实战用途：

1. 获取设备号：`inode` 结构体中包含一个成员 `i_rdev`，它存储了该设备文件的**主次设备号**。 如果你一个驱动对应多个次设备，你可以通过 `iminor(inode)` 宏来判断当前用户打开的是哪一个。

2. 找到自定义的设备结构体，在现代 Linux 驱动编写中，我们通常会定义一个结构体来包含所有设备信息：

   ```c
   struct my_dev {
       struct cdev cdev;    // 字符设备
       int my_variable;     // 自定义变量
       // ...
   };
   ```

   ​	在 `open` 函数中，通过 `inode->i_cdev` 配合 `container_of` 宏，就能精准找到这个结构体：

   ```c
   static int chrdevbase_open(struct inode *inode, struct file *filp)
   {
       struct my_dev *dev;
       
       // 通过 inode 中的 cdev 指针逆向找到包裹它的 my_dev 结构体
       dev = container_of(inode->i_cdev, struct my_dev, cdev);
       
       // 然后存入 filp 中，方便以后的 read/write 函数直接使用
       filp->private_data = dev;
       
       return 0;
   }
   ```

   ​	虽然 `struct inode` 非常庞大，但在字符驱动开发中，只需要关注这几个成员：

   | **成员**                   | **作用**                                                     |
   | -------------------------- | ------------------------------------------------------------ |
   | **`dev_t i_rdev`**         | 真实的设备号（包含主和次）。                                 |
   | **`struct cdev \*i_cdev`** | 指向当前字符设备结构体的指针（我们在 `cdev_add` 时注册的）。 |
   | **`umode_t i_mode`**       | 权限标志（如：该节点是字符设备还是块设备）。                 |

# 4. 具体实现

## 4.1 目的

​	建立一个内核缓冲区，用户空间可以调用对这个缓冲区进行读写。

## 4.2 编写编译驱动程序

​	下面是静态申请设备号的驱动程序：

``` c
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h> 
#include <linux/types.h>
#include <linux/ide.h>
#include <linux/delay.h>

#define CHRDEVBASE_MAJOR 91 //主设备号
#define CHRDEVBASE_NAME "chrdevbase" //设备名字

static char kernel_buf[1024]; //内核缓冲区大小

//打开设备
static int chrdevbase_open(struct inode *inode, struct file *filp)
{
    printk(KERN_INFO "chrdevbase device opened\n");
    return 0;
}

//关闭设备
static int chrdevbase_release(struct inode *inode, struct file *filp)
{
    printk(KERN_INFO "chrdevbase device closed\n");
    return 0;
}

//从内核设备读取数据
static ssize_t chrdevbase_read(struct file *filp, char __user *buf, size_t len, loff_t *offset)
{
    int retvalue;

    //因为内核空间不能直接操作用户空间的内存，因此需要借助copy_to_user函数来完成内核空间的数据到用户空间的复制
    retvalue = copy_to_user(buf, kernel_buf, len); 
    if (retvalue != 0) {
        return -EFAULT;
    }
    printk(KERN_INFO "chrdevbase device read\n");
    return len;
}

//向内核设备写入数据
static ssize_t chrdevbase_write(struct file *filp, const char __user *buf, size_t len, loff_t *offset)
{
    int retvalue;
	
    //因为用户空间内存不能直接访问内核空间的内存，所以需要借助函数copy_from_user将用户空间的数据复制到内核空间中
    retvalue = copy_from_user(kernel_buf, buf, len);
    if (retvalue != 0) {
        return -EFAULT;
    }
    printk(KERN_INFO "chrdevbase device write\n");
    return len;
}

static struct file_operations chrdevbase_fops = {
    .owner = THIS_MODULE,
    .open = chrdevbase_open,
    .release = chrdevbase_release,
    .read = chrdevbase_read,
    .write = chrdevbase_write,
};

//初始化模块
static int __init chrdevbase_init(void)
{
    int result;

    result = register_chrdev(CHRDEVBASE_MAJOR, CHRDEVBASE_NAME, &chrdevbase_fops);
    if (result < 0) {
        printk(KERN_ERR "Failed to register chrdevbase device\n");
        return result;
    }
    printk(KERN_INFO "chrdevbase device registered successfully\n");
    return 0;
}

//卸载模块
static void __exit chrdevbase_exit(void)
{
    unregister_chrdev(CHRDEVBASE_MAJOR, CHRDEVBASE_NAME);
    printk(KERN_INFO "chrdevbase device unregistered successfully\n");
}

module_init(chrdevbase_init);
module_exit(chrdevbase_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("San Syun");
MODULE_DESCRIPTION("A simple character device driver example");
MODULE_INFO(intree, "Y"); //欺骗内核模块管理工具，给本驱动添加intree标记，如果不加就会有“loading out-of-tree module taints kernel.”这个警告
```

​	下面是驱动程序编译makefile脚本，放在与驱动函数的同一个目录即可：

``` makefile
KERNELDIR := /root/rk3568/rk3568_linux_sdk/kernel #根据实际情况填写内核源码目录，利用Linux内核自带的Kbuild编译系统来编译自定义的驱动代码
PWD := $(shell pwd) #当前路径，编写的驱动程序所在位置

ARCH ?= arm64 #芯指定目标处理器的架构。RK3568是64位ARM架构，所以是arm64
CROSS_COMPILE ?= aarch64-buildroot-linux-gnu- #指定交叉编译器的前缀
TOOLCHAIN_DIR ?= /opt/atk-dlrk3568-5_10_sdk-toolchain/bin #指定交叉编译器所在的bin目录，确保脚本能找到aarch64-buildroot-linux-gnu-gcc等工具

#obj-m: 这是内核编译系统特有的变量。它告诉 Kbuild：请将 chrdevbase.c 编译并链接成一个模块文件 chrdevbase.ko。如果想编译进内核（非模块），则会使用 obj-y
obj-m := chrdevbase.o

all:
	PATH=$(TOOLCHAIN_DIR):$$PATH $(MAKE) -C $(KERNELDIR) \
		ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) \
		M=$(PWD) modules

clean:
	PATH=$(TOOLCHAIN_DIR):$$PATH $(MAKE) -C $(KERNELDIR) \
		ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) \
		M=$(PWD) clean
```

​	**`PATH=$(TOOLCHAIN_DIR):$$PATH`**: 临时将编译器路径加入到系统环境变量中，这样执行 `make` 时就能直接调用到交叉编译器。

​	**`$(MAKE) -C $(KERNELDIR)`**: 关键动作。它切换到内核源码目录执行 `make`。这意味着它在利用内核源码根目录下的顶级 Makefile 来处理编译任务。

​	**`	M=$(PWD)`**: 告诉内核 Makefile：“我要编译的外部模块源码就在 `$(PWD)` 这个位置，请在处理完内核必要逻辑后回来编译我”。

​	**`	modules`**: 告诉内核 Makefile，我们只需要编译模块，不需要编译整个内核镜像。

​	编译完成后我们可以在makefile的目录中看到.ko文件，也就是我们后面会用到的驱动。我们将.ko文件发送到开发板/lib/modules/5.10.160目录下即可使用modprobe加载

![image-20260114214152101](..\images\rk3568\01\image-20260114214152101.png)

## 4.3 编写编译测试程序

``` c
#include "stdio.h"
#include "fcntl.h"

int main(int argc, char *argv[])
{
    char *fileName = argv[1];
    int fd;
    fd = open(fileName, O_RDWR);
    if (fd < 0) {
        printf("Cannot open file %s\n", fileName);
        return -1;
    }

    //从内核缓冲区读取数据 
    if(atoi(argv[2])==1){
        char readBuf[1024] = {0};
        int len = atoi(argv[3]);
        int readLen = read(fd, readBuf, len);
        if(readLen < 0) {
            printf("Cannot read file %s\n", fileName);
            return -1;
        }
        printf("Read %d bytes: %s\n", readLen, readBuf);
    }

    //向内核缓冲区写入数据
    if(atoi(argv[2])==2){
        char *writeBuf = argv[3];
        int writeLen = write(fd, writeBuf, sizeof(writeBuf));
        if(writeLen < 0) {
            printf("Cannot write file %s\n", fileName);
            return -1;
        }
        printf("Wrote %d bytes: %s\n", writeLen, writeBuf);
    }

    if(close(fd) < 0) {
        printf("Cannot close file %s\n", fileName);
        return -1;
    }
    return 0;
}
```

​	下面是测试程序编译makefile脚本，放在与测试程序的同一个目录即可：

``` makefile
CC = /opt/atk-dlrk3568-5_10_sdk-toolchain/bin/aarch64-buildroot-linux-gnu-gcc 
CFLAGS = -O2 -Wall
TARGET = mian

all:
	$(CC) $(CFLAGS) mian.c -o $(TARGET)

clean:
	rm -f $(TARGET)
```

## 4.4 上板测试

### 加载驱动

​	注意没有.ko后缀。

``` bash
modprobe chrdevbase
```

![image-20260114220445557](..\images\rk3568\01\image-20260114220445557.png)

​	通过**`	lsmod`**命令即可看到成功加载的驱动，size正是我们内核缓冲区的bit大小（1024*16）

![image-20260114220724921](..\images\rk3568\01\image-20260114220724921.png)

​	通过下述命令创建设备节点

``` bash
mknod /dev/chrdevbase c 91 0 
```

![image-20260114222059077](..\images\rk3568\01\image-20260114222059077.png)

​	至此我们的驱动设备正式可以用了！

### 写缓冲区命令

​	向缓冲区写入“abcdefg”字符串

``` bash
 ./mian /dev/chrdevbase 2 abcdefg
```

![image-20260114222225716](..\images\rk3568\01\image-20260114222225716.png)

### 读缓冲区命令

​	从缓冲区读取长度为3的内容

``` bash
 ./mian /dev/chrdevbase 1 3
```

![image-20260114222413644](..\images\rk3568\01\image-20260114222413644.png)

### 卸载驱动

``` bash
rmmod chrdevbase
```

![image-20260114222726659](..\images\rk3568\01\image-20260114222726659.png)

​	通过rmmod卸载驱动后为什么还能在/dev中找到呢，这是因为我们前面利用**`mknod`**命令创建了一个特殊的文件，除非我们利用rm删除它或者在驱动的exit函数中添加销毁设备逻辑，否则一直都存在。但我们此时再测试读缓冲区，能看到已经无法使用了，说明驱动已经被卸载。

# 驱动框架模板总结

``` c
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h> 
#include <linux/types.h>
#include <linux/ide.h>
#include <linux/delay.h>

#define CHRDEVBASE_MAJOR XXX
#define CHRDEVBASE_NAME "XXXXXX"

//打开设备
static int XXX_open(struct inode *inode, struct file *filp)
{
    return 0;
}

//关闭设备
static int XXX_release(struct inode *inode, struct file *filp)
{
    return 0;
}

//从内核设备读取数据
static ssize_t XXX_read(struct file *filp, char __user *buf, size_t len, loff_t *offset)
{
    return xxx;
}

//向内核设备写入数据
static ssize_t XXX_write(struct file *filp, const char __user *buf, size_t len, loff_t *offset)
{
    return len;
}

static struct file_operations XXX_fops = {
    .owner = THIS_MODULE,
    .open = XXX_open,
    .release = XXX_release,
    .read = XXX_read,
    .write = XXX_write,
};

//初始化模块
static int __init XXX_init(void)
{

    return 0;
}

//卸载模块
static void __exit XXX_exit(void)
{

}

module_init(XXX_init);
module_exit(XXX_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("San Syun");
MODULE_INFO(intree, "Y"); //欺骗内核模块管理工具
```

